#!/bin/bash
#
# $Id: breed.sh,v 1.1 2007-01-24 15:43:56 neo Exp $
#
# Author:   Gong Jie <neo@mamiyami.com>
# Create:   2007-01-24
# Update:   2007-01-24
# Version:  0.9.3

#
# warn_if_bad		Put out warning message(s) if $1 has bad RC.
#
#	$1	0 (pass) or non-zero (fail).
#	$2+	Remaining arguments printed only if the $1 is non-zero.
#
#	Incoming $1 is returned unless it is 0
#
function warn_if_bad()
{
	local -i rc="$1"
	local script="${0##*/}"

	# Ignore if no problems
	[ "$rc" -eq "0" ] && return 0

	# Broken
	shift
	echo "$script: $@" >&2
	return "$rc"
}

#
# exit_if_bad		Put out error message(s) if $1 has bad RC.
#
#	$1	0 (pass) or non-zero (fail).
#	$2+	Remaining arguments printed only if the $1 is non-zero.
#
#               Exits with 1 unless $1 is 0
#
function exit_if_bad()
{
	warn_if_bad "$@" || exit 1
	return 0
}

#
# tc_root_or_break
#
#	Breaks the testcase if not running as root.
#
#	If this returns 1, the invoker MUST abort the testcase.
#
#	returns 0 if running as root
#	returns 1 if not (and breaks testcase)
#
function check_root_or_exit()
{
	[ "$UID" -eq "0" ]
	exit_if_bad "$?" "Must be run by UID=0. Actual UID=$UID."
	return 0
}

#
# check_executes	Check for executable(s)
#
#	Returns 0 if true.
#	Returns 1 if not.
#
function check_executes()
{
	local cmd
	local all_ok="yes"
	for cmd in "$@"
	do
		if ! type "$cmd" &>/dev/null
		then
			echo "Command \"$cmd\" not found" >&2
			all_ok="no"
		fi
	done
	[ "$all_ok" = "yes" ]
}

#
# check_exec_or_exit	Check for required executables.
#
#	Exits (not returns) if commands listed on command line do not exist.
#
#	Returns 0 if true.
#	Exits with 1 if not.
#
function check_exec_or_exit()
{
	check_executes "$@"
	exit_if_bad "$?" "Above listed required command(s) not found"
	return 0
}

#
# internal_setup	Script setup
#
#	Returns 0 on success.
#	Exits (not returns) with 1 on failure.
#
function internal_setup()
{
	# Trap exit for internal_cleanup function.
	trap "internal_cleanup" 0

	umask 0077

	exec 3>&1
	exec 4>&2

	check_exec_or_exit cat cpio find grep tail touch xargs
}

#
# internal_cleanup	Script cleanup (reached via trap 0)
#
#	Destory any temporarily facility created by internal_setup.
#
function internal_cleanup()
{
	exec 3>&-
	exec 4>&-
}

function write_header_file()
{
	local file="$1"

	cat <<EOF >"$file"
/*  This file is automatic generated by breed.sh.  Please do not edit this
 *  file by hand.
 */
/** @file $file
 *  @author Gong Jie <neo@mamiyami.com>
 */

#ifndef __INTELLIGENCE_X_HPP__
#define __INTELLIGENCE_X_HPP__

namespace checkers
{
	namespace evaluate
	{
		const int WEIGHT_PIECES    = 256;
		const int WEIGHT_KINGS     = ${WEIGHTS[0]};
		const int WEIGHT_MOVERS    = ${WEIGHTS[1]};
		const int WEIGHT_KINGS_ROW = ${WEIGHTS[2]};
		const int WEIGHT_EDGES     = ${WEIGHTS[3]};
	}
}

#endif // __INTELLIGENCE_X_HPP__
// End of file
EOF
}

function resolve_head_file()
{
	local file="$1"

	[ -f "$file" ] || return 1

	WEIGHTS[0]="$(awk '/WEIGHT_KINGS/ { print $5 }' <"$file" | cut -d ';' -f 1)"
	WEIGHTS[1]="$(awk '/WEIGHT_MOVERS/ { print $5 }' <"$file" | cut -d ';' -f 1)"
	WEIGHTS[2]="$(awk '/WEIGHT_KINGS_ROW/ { print $5 }' <"$file" | cut -d ';' -f 1)"
	WEIGHTS[3]="$(awk '/WEIGHT_EDGES/ { print $5 }' <"$file" | cut -d ';' -f 1)"

	return 0;
}

function create_generation_0()
{
	local gen="000000"
	local dir="breed/gen-$gen"
	local file=""
	local i=""

	rm -rf "$dir"
	mkdir -p "$dir"

	for i in $(seq -f "%03g" 000 127)
	do
		file=$(mktemp -p "$dir" "intell-$gen-$i-XXXXXXXXXXXX")
		WEIGHTS[0]="$(($RANDOM % 256))"
		WEIGHTS[1]="$(($RANDOM % 256))"
		WEIGHTS[2]="$(($RANDOM % 256))"
		WEIGHTS[3]="$(($RANDOM % 256))"
		write_header_file "$file"
	done
}

function compile()
{
	local gen=$(printf "%06d" "$1")
	local dir="breed/gen-$gen"
	local tmp_dir="/tmp/compile-$$"
	local uid=""
	local f=""
	
	mkdir -p "$tmp_dir"
	cp "$BASE_DIR"/{*.{h,c}pp,Makefile} "$tmp_dir"

	for f in "$dir"/*
	do
		uid="${f##*/intell-}"
		if [ ! -x "$dir/ponder-$uid" ]
		then
			cp "$f" "$tmp_dir/intelligence_x.hpp"
			make -C "$tmp_dir" ponder
			strip "$tmp_dir/ponder"
			cp "$tmp_dir/ponder" "$dir/ponder-$uid"
		fi
	done

	rm -rf "$tmp_dir"
}

function gen_run_list()
{
	local gen=$(printf "%06d" "$1")
	local dir="breed/gen-$gen"
	local uid1=""
	local uid2=""
	local f1=""
	local f2=""

	mkdir -p "$dir/run"

	for f1 in "$dir"/ponder-*
	do
		uid1="${f1##*/ponder-}"
		for f2 in "$dir"/ponder-*
		do
			uid2="${f2##*/ponder-}"
			if [ "$uid1" = "$uid2" ]
			then
				continue
			fi
			echo "$BASE_DIR/runer --black $f1 --white $f2 --depth 2" >"$dir/run/run@$uid1@$uid2"
		done
	done
}

function fight()
{
	local gen=$(printf "%06d" "$1")
	local dir="breed/gen-$gen"
	local uid1=""
	local uid2=""
	local f=""

	mkdir -p "$dir/result"

	for f in "$dir"/run/run@*
	do
		uid1=$(echo $f | cut -d @ -f 2)
		uid2=$(echo $f | cut -d @ -f 3)
		echo "$uid1" "$uid2"
		sh -x "$f" >"$dir/result/result@$uid1@$uid2"
		tail -n 1 "$dir/result/result@$uid1@$uid2"
		rm -f "$f"
	done
}

internal_setup

BASE_DIR="${0%/*}"
declare -a WEIGHTS
declare -i GENERATION=0
declare -i MAX_NUMBER=128

cd "${BASE_DIR}"
mkdir -p "breed"

#create_generation_0
#compile 0
#gen_run_list 0
fight 0

exit 0
